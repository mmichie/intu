package pipeline

import (
	"context"
	"errors"

	"github.com/mmichie/intu/pkg/aikit/v2/provider"
)

// SerialPipeline executes providers in sequence, with each provider receiving
// the output of the previous provider
type SerialPipeline struct {
	Providers []provider.Provider
	BasePipeline
}

// NewSerialPipeline creates a new serial pipeline
func NewSerialPipeline(providers []provider.Provider, opts ...Option) *SerialPipeline {
	options := PipelineOptions{
		MaxRetries: 1,
	}

	// Apply options
	for _, opt := range opts {
		opt(&options)
	}

	return &SerialPipeline{
		Providers: providers,
		BasePipeline: BasePipeline{
			options: options,
		},
	}
}

// Execute processes a text input through a series of providers sequentially
func (p *SerialPipeline) Execute(ctx context.Context, input string) (string, error) {
	if len(p.Providers) == 0 {
		return "", errors.New("no providers configured for serial pipeline")
	}

	// Start with the input
	currentText := input

	// Process through each provider in sequence
	for _, prov := range p.Providers {
		// Create a request for this provider
		request := provider.Request{
			Prompt: currentText,
		}

		// Execute with retries
		var response provider.Response
		var err error

		attemptsLeft := p.options.MaxRetries
		for attemptsLeft > 0 {
			attemptsLeft--

			// Process with the current provider
			response, err = prov.GenerateResponse(ctx, request)

			// If successful, break
			if err == nil {
				break
			}

			// Exit if no more attempts or context canceled
			if attemptsLeft <= 0 || errors.Is(ctx.Err(), context.Canceled) {
				break
			}
		}

		// Check for error after all attempts
		if err != nil {
			return "", err
		}

		// Use the result as input for the next provider
		currentText = response.Content
	}

	return currentText, nil
}

// ExecuteWithRequest executes a provider request through each provider sequentially
func (p *SerialPipeline) ExecuteWithRequest(ctx context.Context, request provider.Request) (provider.Response, error) {
	if len(p.Providers) == 0 {
		return provider.Response{}, errors.New("no providers configured for serial pipeline")
	}

	// Start with the initial request
	currentRequest := request

	// Process through each provider in sequence
	for i, providerObj := range p.Providers {
		// Execute with retries
		var response provider.Response
		var err error

		attemptsLeft := p.options.MaxRetries
		for attemptsLeft > 0 {
			attemptsLeft--

			// Process with the current provider
			response, err = providerObj.GenerateResponse(ctx, currentRequest)

			// If successful, break
			if err == nil {
				break
			}

			// Exit if no more attempts or context canceled
			if attemptsLeft <= 0 || errors.Is(ctx.Err(), context.Canceled) {
				break
			}
		}

		// Check for error after all attempts
		if err != nil {
			return provider.Response{}, err
		}

		// Use the result as input for the next provider
		if i < len(p.Providers)-1 {
			currentRequest = provider.Request{
				Prompt:           response.Content,
				FunctionRegistry: currentRequest.FunctionRegistry,
				FunctionExecutor: currentRequest.FunctionExecutor,
				Temperature:      currentRequest.Temperature,
				MaxTokens:        currentRequest.MaxTokens,
			}
		} else {
			// This is the final response, so return it
			return response, nil
		}
	}

	// This should never happen if we have at least one provider
	return provider.Response{}, errors.New("no response generated by serial pipeline")
}

// WithOptions returns a new pipeline with the options applied
func (p *SerialPipeline) WithOptions(opts ...Option) Pipeline {
	// Copy current options
	newOptions := p.options

	// Apply new options
	for _, opt := range opts {
		opt(&newOptions)
	}

	// Create a new pipeline with the updated options
	return &SerialPipeline{
		Providers: p.Providers,
		BasePipeline: BasePipeline{
			options: newOptions,
		},
	}
}
